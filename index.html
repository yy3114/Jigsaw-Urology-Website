```html
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ³Œå°¿ç³»çµ± 36ç‰‡æ‹¼åœ–éŠæˆ² - äº’é–é¸å€ç‰ˆ</title>
    <!-- è¼‰å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* è¨­ç½® Inter å­—é«” */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* æ·ºè—ç°è‰²èƒŒæ™¯ */
        }
        /* æ‹¼åœ–å¡Šçš„æ‹–æ›³å®¹å™¨ï¼Œå¿…é ˆæ˜¯ relative */
        #jigsaw-app {
            position: relative; 
        }
        /* ä¸»æ‹¼åœ–æ ¼ç¶² (å¸é™„ç›®æ¨™) */
        #puzzle-grid {
            position: relative;
            user-select: none;
            touch-action: none; 
            box-shadow: 0 10px 30px rgba(44, 62, 80, 0.15);
            border: 4px solid #3498db; /* è—è‰²é‚Šæ¡† */
        }
        /* å–®å€‹æ‹¼åœ–å¡Šçš„æ¨£å¼ */
        .puzzle-piece {
            /* åˆå§‹åœ¨æ‰˜ç›¤ä¸­æ™‚ï¼Œä½¿ç”¨ relative layout */
            position: relative; 
            cursor: grab;
            transition: box-shadow 0.1s;
            box-sizing: border-box; 
            mask-image: none;
            -webkit-mask-image: none;
            mask-repeat: no-repeat;
            -webkit-mask-repeat: no-repeat;
            /* ä¿®æ­£ï¼šåœ¨åœ–ç‰‡è¼‰å…¥å‰é¡¯ç¤ºï¼Œç¢ºèªé‚Šç•Œæ¡†å­˜åœ¨ */
            background-color: #f5f5f5; 
            border: 1px solid #ccc; 
            z-index: 10; 
            margin: 4px; /* é–“è· */
        }
        /* æ‹¼åœ–å¡Šè¢«æ‹–æ›³æ™‚çš„æ¨£å¼ (position: absolute) */
        .puzzle-piece.dragging {
            position: absolute; 
            z-index: 100; 
            cursor: grabbing;
            box-shadow: 0 0 20px rgba(230, 126, 34, 0.8);
            transform: scale(1.05); 
            border: none; /* æ‹–æ›³æ™‚ç§»é™¤é‚Šæ¡† */
        }
        /* ç¾åŒ–è¨ˆæ™‚å™¨æ¨£å¼ */
        #timer {
            background-color: #ffffff;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        #timer:hover {
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
    </style>
</head>
<body class="p-4 sm:p-8 flex flex-col items-center justify-center min-h-screen">

    <div class="w-full max-w-4xl">
        <h1 class="text-4xl font-bold text-center mb-2 text-gray-800">ğŸ§© æ³Œå°¿ç³»çµ± 36ç‰‡æ‹¼åœ–æŒ‘æˆ° (äº’é–é¸å€ç‰ˆ)</h1>
        <p class="text-center mb-6 text-gray-600">å¾ä¸‹æ–¹æ‰˜ç›¤é¸å€æ‹–æ›³æ‹¼åœ–å¡Šè‡³ä¸»åœ–æ¡†å®ŒæˆæŒ‘æˆ°ã€‚</p>
    </div>

    <div id="jigsaw-app" class="w-full max-w-4xl flex flex-col lg:flex-row gap-6">
        
        <!-- åƒè€ƒåœ– & æ§åˆ¶å€ (å·¦å´/é ‚éƒ¨) -->
        <div class="lg:w-80 flex-shrink-0 order-1">
            <div class="bg-white p-4 rounded-xl shadow-lg mb-6">
                <h2 class="text-xl font-semibold mb-3 text-gray-700">åƒè€ƒåœ–</h2>
                <!-- åœ–ç‰‡ URL -->
                <img id="reference-image" src="https://i.postimg.cc/NjbcgTNw/urinary-system2.jpg" alt="æ³Œå°¿ç³»çµ±åƒè€ƒåœ–" class="w-full h-auto rounded-lg border-2 border-gray-200">
            </div>

            <div class="flex flex-col space-y-3">
                <button id="shuffle-button" class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-6 rounded-xl transition duration-200 shadow-md hover:shadow-lg active:scale-95">
                    é‡æ–°æ´—ç‰Œ
                </button>
                <div id="status-message" class="text-center text-lg font-semibold h-8 text-gray-700">
                    è¼‰å…¥ä¸­...
                </div>
                <div id="timer" class="text-center text-lg font-semibold text-gray-700">
                    ç”¨æ™‚ï¼š00:00
                </div>
            </div>
        </div>

        <!-- æ‹¼åœ–å€ (å³å´/åº•éƒ¨) -->
        <div class="flex-grow flex justify-center items-start p-2 bg-white rounded-xl shadow-lg order-2">
            <!-- æ‰€æœ‰æ‹¼åœ–å¡Šçš„çµ•å°å®šä½å®¹å™¨ï¼Œä¹Ÿæ˜¯å¸é™„çš„ç›®æ¨™ -->
            <div id="puzzle-grid" class="w-full max-w-full rounded-lg overflow-hidden border-2 border-gray-400">
                <!-- æˆåŠŸæ”¾ç½®çš„æ‹¼åœ–å¡Šå°‡è¢«ç§»å‹•åˆ°é€™è£¡ -->
            </div>
        </div>
    </div>
    
    <!-- æ‹¼åœ–å¡Šé¸å€ (æ‰˜ç›¤) - ç¨ç«‹æ–¼ä¸»æ ¼ç¶²ä¹‹å¤– -->
    <div class="w-full max-w-4xl mt-6">
        <!-- å‰©é¤˜è¨ˆæ•¸å™¨å€åŸŸ (é ‚éƒ¨) -->
        <div class="bg-white p-4 rounded-t-xl shadow-lg border-x-2 border-t-2 border-gray-300">
            <p class="text-xl font-bold text-gray-700">
                å‰©é¤˜æ‹¼åœ–ï¼š<span id="remaining-count" class="text-blue-600 font-extrabold">36</span> å¡Š
            </p>
        </div>

        <!-- æ‰˜ç›¤å®¹å™¨ï¼šå›ºå®šé«˜åº¦ h-48ï¼Œç„¡æ°´å¹³æ»¾å‹• -->
        <div class="bg-white p-4 rounded-b-xl shadow-lg h-48 border-x-2 border-b-2 border-gray-300 overflow-hidden">
            <!-- æ‰˜ç›¤ï¼šflex ä½ˆå±€ï¼Œè‡ªå‹•æ›è¡Œ -->
            <div id="piece-tray" class="flex flex-wrap items-start justify-start h-full overflow-auto">
                <!-- å¾…æ”¾ç½®çš„æ‹¼åœ–å¡Šå°‡è¢«æ”¾ç½®åœ¨é€™è£¡ -->
            </div>
        </div>
    </div>

    <!-- å‹åˆ©/å®Œæˆè¨Šæ¯ Modal -->
    <div id="win-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50 transition-opacity duration-300 opacity-0" aria-modal="true" role="dialog">
        <div class="bg-white p-8 rounded-2xl shadow-2xl text-center max-w-sm w-full transform scale-95 transition-transform duration-300">
            <svg class="mx-auto h-16 w-16 text-green-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            <h3 class="text-2xl font-bold text-gray-800 mb-2">æ­å–œï¼æ‹¼åœ–å®Œæˆï¼</h3>
            <p class="text-gray-600 mb-6">æ‚¨æˆåŠŸå®Œæˆäº† 36 ç‰‡äº’é–æ‹¼åœ–ï¼</p>
            <button id="close-modal-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200 active:scale-95">
                é—œé–‰ä¸¦å†ç©ä¸€æ¬¡
            </button>
        </div>
    </div>


    <script>
        // è¨­å®šå¸¸æ•¸
        const IMAGE_URL = 'https://i.postimg.cc/NjbcgTNw/urinary-system2.jpg'; 
        const ROWS = 6; 
        const COLS = 6; 
        const SNAP_TOLERANCE = 35;
        const TAB_OFFSET_FACTOR = 0.15; 
        const TIME_LIMIT_SECONDS = 600; // 10 åˆ†é˜ = 600 ç§’

        // ç²å– DOM å…ƒç´ 
        const puzzleGrid = document.getElementById('puzzle-grid');
        const pieceTray = document.getElementById('piece-tray');
        const jigsawApp = document.getElementById('jigsaw-app');
        const shuffleButton = document.getElementById('shuffle-button');
        const statusMessage = document.getElementById('status-message');
        const winModal = document.getElementById('win-modal');
        const closeModalButton = document.getElementById('close-modal-button');
        const remainingCountElement = document.getElementById('remaining-count');
        const timerElement = document.getElementById('timer');

        let pieces = [];
        let pieceEdges = {}; 
        let gridW = 0; 
        let gridH = 0; 
        let pieceWidth = 0; 
        let pieceHeight = 0; 
        let tabPadding = 0; 
        let draggedPiece = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let pieceBBoxW = 0;
        let pieceBBoxH = 0;
        let imageLoaded = false; // æ–°å¢ï¼šè¿½è¹¤åœ–ç‰‡æ˜¯å¦è¼‰å…¥
        let timerInterval = null;
        let startTime = null;
        let audioContext = null;

        /**
         * å•Ÿå‹•è¨ˆæ™‚å™¨
         */
        const startTimer = () => {
            if (timerInterval) clearInterval(timerInterval);
            startTime = Date.now();
            timerElement.textContent = 'ç”¨æ™‚ï¼š00:00';
            timerElement.classList.remove('text-red-600');
            timerInterval = setInterval(updateTimer, 1000);
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        };

        /**
         * æ’­æ”¾æ»´ç­”éŸ³æ•ˆ (å°è²)
         */
        const playTickSound = () => {
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // æ»´ç­”é »ç‡
            gainNode.gain.setValueAtTime(0.05, audioContext.currentTime); // å°è² (éŸ³é‡ 5%)
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.05); // çŸ­æš«éŸ³æ•ˆ
        };

        /**
         * æ›´æ–°è¨ˆæ™‚å™¨é¡¯ç¤º
         */
        const updateTimer = () => {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            timerElement.textContent = `ç”¨æ™‚ï¼š${minutes}:${seconds}`;
            if (elapsed >= TIME_LIMIT_SECONDS) {
                timerElement.classList.add('text-red-600');
            }
            playTickSound(); // æ¯ç§’æ’­æ”¾æ»´ç­”éŸ³æ•ˆ
        };

        /**
         * åœæ­¢è¨ˆæ™‚å™¨ä¸¦è¿”å›ç¸½æ™‚é–“å­—ç¬¦ä¸²
         */
        const stopTimer = () => {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            return { timeString: `${minutes}åˆ†${seconds}ç§’`, isWithinLimit: elapsed < TIME_LIMIT_SECONDS };
        };

        /**
         * éš¨æ©Ÿæ´—ç‰Œé™£åˆ—
         */
        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        };

        /**
         * éš¨æ©Ÿç”Ÿæˆæ‹¼åœ–å¡Šçš„é‚Šç·£åœ°åœ– (å‡¹æ§½ 'in' æˆ– å‡¸æ¦« 'out')
         */
        const generateEdgeMap = () => {
            pieceEdges = {};
            const types = ['in', 'out'];
            
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const index = r * COLS + c;
                    
                    if (!pieceEdges[index]) pieceEdges[index] = { top: 'flat', bottom: 'flat', left: 'flat', right: 'flat' };
                    
                    // å‚ç›´é‚Šç·£
                    if (r < ROWS - 1) {
                        const bottomType = types[Math.floor(Math.random() * 2)];
                        pieceEdges[index].bottom = bottomType;
                        const nextIndex = (r + 1) * COLS + c;
                        if (!pieceEdges[nextIndex]) pieceEdges[nextIndex] = { top: 'flat', bottom: 'flat', left: 'flat', right: 'flat' };
                        pieceEdges[nextIndex].top = (bottomType === 'in' ? 'out' : 'in');
                    }
                    
                    // æ°´å¹³é‚Šç·£
                    if (c < COLS - 1) {
                        const rightType = types[Math.floor(Math.random() * 2)];
                        pieceEdges[index].right = rightType;
                        const nextIndex = r * COLS + (c + 1);
                        if (!pieceEdges[nextIndex]) pieceEdges[nextIndex] = { top: 'flat', bottom: 'flat', left: 'flat', right: 'flat' };
                        pieceEdges[nextIndex].left = (rightType === 'in' ? 'out' : 'in');
                    }
                }
            }
        };

        /**
         * æ ¹æ“šé‚Šç·£åœ°åœ–ç”Ÿæˆå–®å€‹æ‹¼åœ–å¡Šçš„ SVG é®ç½©è·¯å¾‘
         */
        const createPieceSVG = (pieceW, pieceH, edgeMap) => {
            const T_FACTOR = 0.3; // Tab width 
            const H_FACTOR = 0.15; // Tab height 
            const C_FACTOR = 0.05; // Control point factor 
            const maxOffset = Math.max(pieceW, pieceH) * H_FACTOR;
            
            // åŸºç¤å°ºå¯¸ (ä¸å«å‡¸æ¦«)
            const w = pieceW;
            const h = pieceH;

            let path = `M 0 0`; // Start at top-left (0, 0)

            const addSidePath = (direction, dim, tabType) => {
                if (tabType === 'flat') {
                    if (direction === 'T') return ` L ${w} 0`;
                    if (direction === 'R') return ` L ${w} ${h}`;
                    if (direction === 'B') return ` L 0 ${h}`;
                    if (direction === 'L') return ` L 0 0`;
                }

                const s = (tabType === 'out' ? 1 : -1); 
                const T_abs = dim * T_FACTOR; 
                const H_abs = dim * H_FACTOR * s; 
                const L_abs = (dim * (1 - T_FACTOR)) / 2; 

                let d_segment = '';
                
                // --- Top Edge (X: 0 -> W, Y: 0) ---
                if (direction === 'T') {
                    d_segment += ` L ${L_abs} 0`;
                    d_segment += ` C ${L_abs + T_abs*C_FACTOR} ${H_abs}, ${L_abs + T_abs*(1-C_FACTOR)} ${H_abs}, ${L_abs + T_abs} 0`;
                    d_segment += ` L ${w} 0`;
                }
                
                // --- Right Edge (X: W, Y: 0 -> H) ---
                else if (direction === 'R') {
                    d_segment += ` L ${w} ${L_abs}`;
                    // æ³¨æ„ï¼šX è»¸åº§æ¨™æ˜¯ w + H_absï¼Œå› ç‚º H_abs æ˜¯ s * å‡¸æ¦«é«˜åº¦
                    d_segment += ` C ${w + H_abs} ${L_abs + T_abs*C_FACTOR}, ${w + H_abs} ${L_abs + T_abs*(1-C_FACTOR)}, ${w} ${L_abs + T_abs}`;
                    d_segment += ` L ${w} ${h}`;
                } 

                // --- Bottom Edge (X: W -> 0, Y: H) ---
                else if (direction === 'B') {
                    // é€™è£¡çš„ s_inv ç¢ºä¿äº†å‡¸æ¦«æ˜¯å‘ä¸‹çš„ (å°æ–¼ 'in') æˆ–æ˜¯å‘ä¸Šçš„ (å°æ–¼ 'out')
                    const s_inv = (tabType === 'out' ? -1 : 1);
                    const H_inv = dim * H_FACTOR * s_inv; 
                    
                    d_segment += ` L ${w - L_abs} ${h}`;
                    // æ³¨æ„ï¼šY è»¸åº§æ¨™æ˜¯ h + H_inv
                    d_segment += ` C ${w - (L_abs + T_abs*C_FACTOR)} ${h + H_inv}, ${w - (L_abs + T_abs*(1-C_FACTOR))} ${h + H_inv}, ${w - L_abs - T_abs} ${h}`;
                    d_segment += ` L 0 ${h}`;
                }

                // --- Left Edge (X: 0, Y: H -> 0) ---
                else if (direction === 'L') {
                    // é€™è£¡çš„ s_inv ç¢ºä¿äº†å‡¸æ¦«æ˜¯å‘å·¦çš„ (å°æ–¼ 'in') æˆ–æ˜¯å‘å³çš„ (å°æ–¼ 'out')
                    const s_inv = (tabType === 'out' ? -1 : 1);
                    const H_inv = dim * H_FACTOR * s_inv; 

                    d_segment += ` L 0 ${h - L_abs}`;
                    // æ³¨æ„ï¼šX è»¸åº§æ¨™æ˜¯ H_inv
                    d_segment += ` C ${H_inv} ${h - (L_abs + T_abs*C_FACTOR)}, ${H_inv} ${h - (L_abs + T_abs*(1-C_FACTOR))}, 0 ${h - L_abs - T_abs}`;
                    d_segment += ` L 0 0`;
                }
                
                return d_segment;
            };

            path += addSidePath('T', w, edgeMap.top);
            path += addSidePath('R', h, edgeMap.right);
            path += addSidePath('B', w, edgeMap.bottom);
            path += addSidePath('L', h, edgeMap.left);
            path += ` Z`;

            // SVG ç¸½å°ºå¯¸ (åŒ…å«æœ€å¤§çš„å‡¸æ¦«åç§»)
            const viewBoxW = w + maxOffset * 2;
            const viewBoxH = h + maxOffset * 2;
            const transformX = maxOffset;
            const transformY = maxOffset;
            
            // ä¿®æ­£ï¼šPath éœ€è¦åœ¨ SVG å…§éƒ¨
            const finalPath = `<path d="${path}" transform="translate(${transformX}, ${transformY})" fill="#000000" />`; // ä½¿ç”¨é»‘è‰²å¡«å……ä½œç‚ºé®ç½©

            return `
                <svg viewBox="0 0 ${viewBoxW} ${viewBoxH}" xmlns="http://www.w3.org/2000/svg" width="${viewBoxW}" height="${viewBoxH}">
                    ${finalPath}
                </svg>
            `;
        };

        /**
         * è¨­ç½®æ‹¼åœ–å®¹å™¨å°ºå¯¸ä¸¦è¨ˆç®—æ‹¼åœ–å¡Šå°ºå¯¸
         */
        const setSizes = () => {
            const parentWidth = puzzleGrid.parentElement.clientWidth;
            // ä½¿ç”¨ min(parentWidth, 800) ä¾†é™åˆ¶æœ€å¤§å°ºå¯¸ï¼Œä½†ç¢ºä¿åœ¨ mobile å¯¬åº¦ä¸‹èƒ½å¡«æ»¿
            const actualContainerWidth = parentWidth; 

            // 1. è¨ˆç®—åŸºç¤ç¶²æ ¼å°ºå¯¸
            pieceWidth = actualContainerWidth / COLS;
            pieceHeight = pieceWidth; 

            gridW = actualContainerWidth;
            gridH = pieceHeight * ROWS;
            
            // 2. è¨­ç½®ä¸»æ ¼ç¶²å°ºå¯¸
            puzzleGrid.style.width = `${gridW}px`;
            puzzleGrid.style.height = `${gridH}px`;

            // 3. è¨ˆç®—å‡¸æ¦«é‚Šç•Œå’Œæ‹¼åœ–å¡Šçš„å¯¦éš›é‚Šç•Œæ¡† (BBox) å°ºå¯¸
            const maxPieceDim = Math.max(pieceWidth, pieceHeight);
            tabPadding = maxPieceDim * TAB_OFFSET_FACTOR;
            pieceBBoxW = pieceWidth + 2 * tabPadding;
            pieceBBoxH = pieceHeight + 2 * tabPadding;
            
            // 4. æ›´æ–°æ‰€æœ‰æ‹¼åœ–å¡Šçš„å°ºå¯¸å’Œä½ç½®æ•¸æ“š
            pieces.forEach(piece => {
                const c = piece.dataset.index % COLS;
                const r = Math.floor(piece.dataset.index / COLS);
                
                const correctGridX = c * pieceWidth;
                const correctGridY = r * pieceHeight;
                
                // æ­£ç¢ºä½ç½® (BBox ç›¸å°æ–¼ Grid çš„ä½ç½®)
                const correctX = correctGridX - tabPadding;
                const correctY = correctGridY - tabPadding;
                
                piece.dataset.correctX = correctX;
                piece.dataset.correctY = correctY;
                
                // è¨­ç½®æ‹¼åœ–å¡Š BBox å°ºå¯¸
                piece.style.width = `${pieceBBoxW}px`;
                piece.style.height = `${pieceBBoxH}px`;
                
                // è¨­ç½®èƒŒæ™¯åœ–ç‰‡å¤§å°å’Œä½ç½® (åƒ…åœ¨åœ–ç‰‡è¼‰å…¥æˆåŠŸæ™‚)
                if (imageLoaded) {
                    piece.style.backgroundSize = `${gridW}px ${gridH}px`;
                    // ä¿®æ­£ï¼šbackgroundPosition çš„åç§»é‡æ˜¯ (æ­£ç¢ºç¶²æ ¼ä½ç½® + tabPadding)
                    piece.style.backgroundPosition = `-${correctGridX + tabPadding}px -${correctGridY + tabPadding}px`;
                }

                // é‡æ–°ç”Ÿæˆ/æ‡‰ç”¨ SVG é®ç½©
                const edgeMap = pieceEdges[piece.dataset.index];
                if (edgeMap) {
                    const svgContent = createPieceSVG(pieceWidth, pieceHeight, edgeMap);
                    // ä¿®æ­£ï¼šä½¿ç”¨ encodeURIComponent ç¢ºä¿ SVG å…§å®¹æ­£ç¢ºè™•ç†
                    const encodedSVG = encodeURIComponent(svgContent);
                    const svgUrl = `url('data:image/svg+xml;charset=utf8,${encodedSVG}')`;

                    piece.style.maskImage = svgUrl;
                    piece.style.webkitMaskImage = svgUrl;
                    piece.style.maskSize = `100% 100%`;
                    piece.style.webkitMaskSize = `100% 100%`;
                }

                // å¦‚æœæ‹¼åœ–å¡Šå·²ç¶“åœ¨æ­£ç¢ºä½ç½® (å·²å¸é™„)ï¼Œæ›´æ–°å…¶ style.left/top
                if (piece.dataset.isCorrect === 'true' && piece.parentElement === puzzleGrid) {
                    piece.style.left = `${correctX}px`;
                    piece.style.top = `${correctY}px`;
                }
            });
        };

        /**
         * æ›´æ–°å‰©é¤˜æ‹¼åœ–å¡Šçš„æ•¸é‡é¡¯ç¤º
         */
        const updateRemainingCount = () => {
            const count = pieceTray.children.length;
            if (remainingCountElement) {
                remainingCountElement.textContent = count;
            }
            if (count > 0) {
                 statusMessage.textContent = `æ‹–æ›³æ‹¼åœ–å¡Š (${count} å¡Šå‰©é¤˜)...`;
            } else {
                 statusMessage.textContent = 'æ‰€æœ‰æ‹¼åœ–å¡Šå·²æ”¾ç½®ã€‚æª¢æŸ¥å‹åˆ©æ¢ä»¶...';
            }
        };

        /**
         * å‰µå»ºä¸¦åˆå§‹åŒ–æ‰€æœ‰æ‹¼åœ–å¡Š
         */
        const createPieces = () => {
            puzzleGrid.innerHTML = '';
            pieceTray.innerHTML = '';
            pieces = [];
            
            generateEdgeMap(); 

            const img = new Image();
            img.onload = () => {
                imageLoaded = true; // è¨­ç½®åœ–ç‰‡è¼‰å…¥æˆåŠŸæ——æ¨™
                statusMessage.textContent = 'åœ–ç‰‡è¼‰å…¥æˆåŠŸï¼Œæ­£åœ¨ç”Ÿæˆæ‹¼åœ–å¡Š...';
                
                // å¿…é ˆåœ¨ç”Ÿæˆæ‹¼åœ–å¡Šä¹‹å‰è¨ˆç®—å¥½å°ºå¯¸
                setSizes(); 
                
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const pieceIndex = r * COLS + c;
                        const piece = document.createElement('div');
                        
                        piece.dataset.index = pieceIndex;
                        piece.dataset.isCorrect = 'false';
                        piece.classList.add('puzzle-piece');
                        
                        piece.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
                        piece.style.backgroundImage = `url(${IMAGE_URL})`; 

                        pieces.push(piece);
                        pieceTray.appendChild(piece);
                    }
                }
                
                // å†æ¬¡å‘¼å« setSizes ä»¥ç¢ºä¿æ‰€æœ‰æ–°ç”Ÿæˆçš„ piece ç²å¾—æ­£ç¢ºçš„å°ºå¯¸å’ŒèƒŒæ™¯å®šä½
                setSizes(); 
                shufflePieces();
                attachPieceListeners(); 
                updateRemainingCount(); 
                startTimer(); // å•Ÿå‹•è¨ˆæ™‚å™¨
            };
            img.onerror = () => {
                imageLoaded = false;
                statusMessage.textContent = 'âŒ åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²å€æˆ–åœ–ç‰‡ä¾†æºã€‚';
                // å³ä½¿åœ–ç‰‡å¤±æ•—ï¼Œä¹Ÿè¦åˆå§‹åŒ–ç©ºæ‹¼åœ–å¡Šï¼Œè®“ä½¿ç”¨è€…è‡³å°‘å¯ä»¥ç©å½¢ç‹€é…å°
                setSizes(); 
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const pieceIndex = r * COLS + c;
                        const piece = document.createElement('div');
                        piece.dataset.index = pieceIndex;
                        piece.dataset.isCorrect = 'false';
                        piece.classList.add('puzzle-piece');
                        piece.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
                        pieces.push(piece);
                        pieceTray.appendChild(piece);
                    }
                }
                setSizes();
                shufflePieces();
                attachPieceListeners(); 
                updateRemainingCount(); 
                startTimer(); // å•Ÿå‹•è¨ˆæ™‚å™¨
            }
            img.src = IMAGE_URL;
        };

        /**
         * å°‡æ‹¼åœ–å¡Šéš¨æ©Ÿæ•£ä½ˆ (æ­¤è™•ç‚ºæ”¾å…¥æ‰˜ç›¤ä¸¦æ´—ç‰Œ)
         */
        const shufflePieces = () => {
            statusMessage.textContent = 'æ‹–æ›³æ‹¼åœ–å¡Šä¾†å®Œæˆåœ–ç‰‡...';
            winModal.classList.add('hidden', 'opacity-0', 'scale-95');

            shuffleArray(pieces);
            
            // è¨­å®šæ‰˜ç›¤ç‚º flex ä½ˆå±€ï¼Œè‡ªå‹•æ›è¡Œ
            pieceTray.innerHTML = '';
            pieces.forEach((piece) => {
                if (piece.parentElement !== pieceTray) {
                    pieceTray.appendChild(piece);
                }
                piece.dataset.isCorrect = 'false';
                piece.classList.remove('dragging');
                piece.style.position = 'relative'; 
                piece.style.left = '';
                piece.style.top = '';
                piece.style.zIndex = '10';
                piece.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
                piece.style.cursor = 'grab';
            });
            
            updateRemainingCount();
            checkWin(); 
        };

        /**
         * æª¢æŸ¥æ‹¼åœ–æ˜¯å¦å®Œæˆ
         */
        const checkWin = () => {
            const piecesInGrid = Array.from(puzzleGrid.children);
            if (piecesInGrid.length !== ROWS * COLS) return;

            const isFinished = piecesInGrid.every(piece => piece.dataset.isCorrect === 'true');
            if (isFinished) {
                const { timeString, isWithinLimit } = stopTimer();
                if (isWithinLimit) {
                    statusMessage.textContent = `æ­å–œå®Œæˆï¼Œå¥½æ£’æ£’ï¼Œå¾ˆå²å®³ï¼ç”¨æ™‚ï¼š${timeString}`;
                } else {
                    statusMessage.textContent = `ğŸ¥³ å®Œç¾ï¼æ‹¼åœ–å·²å®Œæˆï¼ç”¨æ™‚ï¼š${timeString}`;
                }
                
                winModal.classList.remove('hidden');
                setTimeout(() => {
                    winModal.classList.add('flex', 'opacity-100', 'scale-100');
                    winModal.classList.remove('opacity-0', 'scale-95');
                }, 10);
                
                pieces.forEach(piece => {
                    piece.onmousedown = null;
                    piece.ontouchstart = null;
                    piece.style.cursor = 'default';
                    piece.style.boxShadow = '0 0 15px rgba(46, 204, 113, 0.8)';
                });
            }
        };

        /**
         * æ‹–æ›³é–‹å§‹è™•ç†å‡½æ•¸
         */
        const handleDragStart = (e) => {
            e.preventDefault(); 
            draggedPiece = e.currentTarget;
            
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            const rect = draggedPiece.getBoundingClientRect();
            dragOffsetX = clientX - rect.left;
            dragOffsetY = clientY - rect.top;

            // é—œéµæ­¥é©Ÿï¼šå°‡æ‹¼åœ–å¡Šç§»å‹•åˆ°ä¸»å®šä½ä¸Šä¸‹æ–‡ (#jigsaw-app)
            jigsawApp.appendChild(draggedPiece); 
            
            // å°‡æ‹¼åœ–å¡Šåˆ‡æ›ç‚ºçµ•å°å®šä½ï¼Œä¸¦è¨ˆç®—ç›¸å°æ–¼ #jigsaw-app çš„èµ·å§‹åº§æ¨™
            const appRect = jigsawApp.getBoundingClientRect();
            draggedPiece.style.position = 'absolute'; 
            draggedPiece.style.left = `${rect.left - appRect.left}px`;
            draggedPiece.style.top = `${rect.top - appRect.top}px`;
            
            draggedPiece.classList.add('dragging');
            draggedPiece.dataset.isCorrect = 'false';
            statusMessage.textContent = 'æ­£åœ¨ç§»å‹•æ‹¼åœ–å¡Š...';
            
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);
            document.addEventListener('touchmove', handleDragMove, { passive: false });
            document.addEventListener('touchend', handleDragEnd);
        };

        /**
         * æ‹–æ›³ç§»å‹•è™•ç†å‡½æ•¸
         */
        const handleDragMove = (e) => {
            if (!draggedPiece) return;

            if (e.type === 'touchmove') e.preventDefault(); 

            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            const appRect = jigsawApp.getBoundingClientRect();

            // è¨ˆç®—æ–°çš„ä½ç½® (ç›¸å°æ–¼ #jigsaw-app)
            let newX = clientX - appRect.left - dragOffsetX;
            let newY = clientY - appRect.top - dragOffsetY;

            draggedPiece.style.left = `${newX}px`;
            draggedPiece.style.top = `${newY}px`;
        };

        /**
         * æ‹–æ›³çµæŸè™•ç†å‡½æ•¸
         */
        const handleDragEnd = () => {
            if (!draggedPiece) return;

            const gridRect = puzzleGrid.getBoundingClientRect();
            const trayRect = pieceTray.getBoundingClientRect();

            // 1. è¨ˆç®—ç•¶å‰æ‹¼åœ–å¡Šä½ç½®ç›¸å°æ–¼ä¸»æ ¼ç¶² (puzzleGrid) çš„åº§æ¨™
            const pieceRect = draggedPiece.getBoundingClientRect();
            const currentXInGrid = pieceRect.left - gridRect.left;
            const currentYInGrid = pieceRect.top - gridRect.top;

            const correctX = parseFloat(draggedPiece.dataset.correctX);
            const correctY = parseFloat(draggedPiece.dataset.correctY);
            
            let snapped = false;

            // 2. æª¢æŸ¥æ˜¯å¦æ¥è¿‘æ­£ç¢ºä½ç½® (å¸é™„é‚è¼¯ï¼Œåªåœ¨ä¸»å€)
            if (Math.abs(currentXInGrid - correctX) < SNAP_TOLERANCE &&
                Math.abs(currentYInGrid - correctY) < SNAP_TOLERANCE) {
                
                // æª¢æŸ¥è©²ä½ç½®æ˜¯å¦å·²ç¶“è¢«ä½”æ“š
                const isSpotTaken = Array.from(puzzleGrid.children).some(p => {
                    return p !== draggedPiece && 
                           p.dataset.isCorrect === 'true' && 
                           parseFloat(p.dataset.correctX) === correctX &&
                           parseFloat(p.dataset.correctY) === correctY;
                });

                if (!isSpotTaken) {
                    snapped = true;
                    
                    // 3. å¸é™„åˆ°æ­£ç¢ºä½ç½® (åˆ‡æ›çˆ¶å…ƒç´ ç‚º #puzzle-grid)
                    puzzleGrid.appendChild(draggedPiece);
                    
                    draggedPiece.style.position = 'absolute'; // ç¢ºä¿åœ¨ Grid å…§ä¿æŒçµ•å°å®šä½
                    draggedPiece.style.left = `${correctX}px`;
                    draggedPiece.style.top = `${correctY}px`;
                    
                    draggedPiece.dataset.isCorrect = 'true';
                    draggedPiece.style.zIndex = '1';
                    draggedPiece.style.boxShadow = '0 0 10px rgba(46, 204, 113, 0.5)';
                    statusMessage.textContent = 'ä¸€å¡Šæ”¾å°äº†ï¼ğŸ‘';
                }
            }
            
            // 4. æ¸…ç†ç‹€æ…‹å’Œä½ç½®
            if (!snapped) {
                // æœªå¸é™„ï¼Œè¿”å›æ‰˜ç›¤ (æ¢å¾©ç›¸å°å®šä½)
                pieceTray.appendChild(draggedPiece);
                draggedPiece.dataset.isCorrect = 'false';
                
                draggedPiece.style.position = 'relative'; 
                draggedPiece.style.left = ''; 
                draggedPiece.style.top = '';
                draggedPiece.style.zIndex = '10';
                draggedPiece.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)'; 
            }

            draggedPiece.classList.remove('dragging');
            draggedPiece = null;

            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
            document.removeEventListener('touchmove', handleDragMove);
            document.removeEventListener('touchend', handleDragEnd);
            
            updateRemainingCount(); 
            checkWin();
        };

        /**
         * é™„åŠ äº‹ä»¶ç›£è½å™¨åˆ°æ‰€æœ‰æ‹¼åœ–å¡Š
         */
        const attachPieceListeners = () => {
            pieces.forEach(piece => {
                piece.onmousedown = handleDragStart;
                piece.ontouchstart = handleDragStart;
            });
        };
        
        /**
         * è¨­ç½®è¦–çª—å¤§å°æ”¹è®Šäº‹ä»¶å’ŒæŒ‰éˆ•äº‹ä»¶
         */
        const setupEventListeners = () => {
            shuffleButton.addEventListener('click', () => {
                createPieces();
                startTimer(); // é‡æ–°æ´—ç‰Œæ™‚é‡ç½®è¨ˆæ™‚å™¨
            }); 
            closeModalButton.addEventListener('click', () => {
                winModal.classList.add('opacity-0', 'scale-95');
                winModal.classList.remove('flex', 'opacity-100', 'scale-100');
                setTimeout(() => {
                    winModal.classList.add('hidden');
                }, 300);
                createPieces(); 
            });
            
            // ä½¿ç”¨ ResizeObserver ä¾†è™•ç†éŸ¿æ‡‰å¼ä½ˆå±€
            const resizeObserver = new ResizeObserver(() => {
                // åªæœ‰ç•¶æ‰€æœ‰æ‹¼åœ–å¡Šåˆå§‹åŒ–å®Œæˆå¾Œæ‰åŸ·è¡Œ setSizes
                if (pieces.length === ROWS * COLS) { 
                    setSizes(); 
                }
            });

            // è§€å¯Ÿçˆ¶å®¹å™¨çš„å°ºå¯¸è®ŠåŒ–
            resizeObserver.observe(puzzleGrid.parentElement);
        };

        /**
         * å•Ÿå‹•éŠæˆ²
         */
        window.onload = () => {
            createPieces();
            setupEventListeners();
        };

    </script>
</body>
</html>
```
